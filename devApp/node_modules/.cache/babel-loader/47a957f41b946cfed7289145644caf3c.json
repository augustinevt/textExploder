{"ast":null,"code":"var arguments$1 = arguments;\n/**\n * [![npm version](https://img.shields.io/npm/v/tonal-key.svg?style=flat-square)](https://www.npmjs.com/package/tonal-key)\n * [![tonal](https://img.shields.io/badge/tonal-key-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-key` is a collection of functions to query about tonal keys.\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * @example\n * // es6\n * import * as Key from \"tonal-key\"\n * // es5\n * const Key = require(\"tonal-key\")\n *\n * @example\n * Key.scale(\"E mixolydian\") // => [ \"E\", \"F#\", \"G#\", \"A\", \"B\", \"C#\", \"D\" ]\n * Key.relative(\"minor\", \"C major\") // => \"A minor\"\n *\n * @module Key\n */\n\nimport { rotate, range } from \"tonal-array\";\nimport { tokenize as split, altToAcc } from \"tonal-note\";\nimport { trFifths, fifths, interval, transpose } from \"tonal-distance\";\nimport { fromDegree, decimal } from \"tonal-roman-numeral\";\nvar MODES = \"major dorian phrygian lydian mixolydian minor locrian ionian aeolian\".split(\" \");\nvar NUMS = [0, 1, 2, 3, 4, 5, 6, 0, 5];\nvar NOTES = \"C D E F G A B\".split(\" \");\nvar TRIADS = [\"\", \"m\", \"m\", \"\", \"\", \"m\", \"dim\"];\nvar SEVENTHS = \"Maj7 m7 m7 Maj7 7 m7 m7b5\".split(\" \");\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5, 0, 3];\n\nvar modenum = function (mode) {\n  return NUMS[MODES.indexOf(mode)];\n};\n/**\n * Get a list of valid mode names. The list of modes will be always in\n * increasing order (ionian to locrian)\n *\n * @function\n * @param {Boolean} alias - true to get aliases names\n * @return {Array} an array of strings\n * @example\n * Key.modes() // => [ \"ionian\", \"dorian\", \"phrygian\", \"lydian\",\n * // \"mixolydian\", \"aeolian\", \"locrian\" ]\n * Key.modes(true) // => [ \"ionian\", \"dorian\", \"phrygian\", \"lydian\",\n * // \"mixolydian\", \"aeolian\", \"locrian\", \"major\", \"minor\" ]\n */\n\n\nexport var modeNames = function (aliases) {\n  return aliases === true ? MODES.slice() : MODES.slice(0, 7);\n};\n/**\n * Create a major key from alterations\n *\n * @function\n * @param {Integer} alt - the alteration number (positive sharps, negative flats)\n * @return {Key} the key object\n * @example\n * Key.fromAlter(2) // => \"D major\"\n */\n\nexport var fromAlter = function (i) {\n  return trFifths(\"C\", i) + \" major\";\n};\nexport var names = function (alt) {\n  if (alt === void 0) alt = 4;\n  alt = Math.abs(alt);\n  var result = [];\n\n  for (var i = -alt; i <= alt; i++) {\n    result.push(fromAlter(i));\n  }\n\n  return result;\n};\nvar NO_KEY = Object.freeze({\n  name: null,\n  tonic: null,\n  mode: null,\n  modenum: null,\n  intervals: [],\n  scale: [],\n  alt: null,\n  acc: null\n});\n\nvar properties = function (name) {\n  var p = tokenize(name);\n\n  if (p[0] === null) {\n    return NO_KEY;\n  }\n\n  var k = {\n    tonic: p[0],\n    mode: p[1]\n  };\n  k.name = k.tonic + \" \" + k.mode;\n  k.modenum = modenum(k.mode);\n  var cs = rotate(k.modenum, NOTES);\n  k.alt = fifths(\"C\", k.tonic) - FIFTHS[MODES.indexOf(k.mode)];\n  k.acc = altToAcc(k.alt);\n  k.intervals = cs.map(interval(cs[0]));\n  k.scale = k.intervals.map(transpose(k.tonic));\n  return Object.freeze(k);\n};\n\nvar memo = function (fn, cache) {\n  if (cache === void 0) cache = {};\n  return function (str) {\n    return cache[str] || (cache[str] = fn(str));\n  };\n};\n/**\n * Return the a key properties object with the following information:\n *\n * - name {string}: name\n * - tonic {string}: key tonic\n * - mode {string}: key mode\n * - modenum {Number}: mode number (0 major, 1 dorian, ...)\n * - intervals {Array}: the scale intervals\n * - scale {Array}: the scale notes\n * - acc {string}: accidentals of the key signature\n * - alt {Number}: alteration number (a numeric representation of accidentals)\n *\n * @function\n * @param {string} name - the key name\n * @return {Object} the key properties object or null if not a valid key\n *\n * @example\n * Key.props(\"C3 dorian\") // => { tonic: \"C\", mode: \"dorian\", ... }\n */\n\n\nexport var props = memo(properties);\n/**\n * Get scale of a key\n *\n * @function\n * @param {string|Object} key\n * @return {Array} the key scale\n *\n * @example\n * Key.scale(\"A major\") // => [ \"A\", \"B\", \"C#\", \"D\", \"E\", \"F#\", \"G#\" ]\n * Key.scale(\"Bb minor\") // => [ \"Bb\", \"C\", \"Db\", \"Eb\", \"F\", \"Gb\", \"Ab\" ]\n * Key.scale(\"C dorian\") // => [ \"C\", \"D\", \"Eb\", \"F\", \"G\", \"A\", \"Bb\" ]\n * Key.scale(\"E mixolydian\") // => [ \"E\", \"F#\", \"G#\", \"A\", \"B\", \"C#\", \"D\" ]\n */\n\nexport var scale = function (str) {\n  return props(str).scale;\n};\n/**\n * Get a list of key scale degrees in roman numerals\n * @param {string} keyName\n * @return {Array}\n * @example\n * Key.degrees(\"C major\") => [\"I\", \"ii\", \"iii\", \"IV\", \"V\", \"vi\", \"vii\"]\n */\n\nexport var degrees = function (str) {\n  var p = props(str);\n\n  if (p.name === null) {\n    return [];\n  }\n\n  var chords = rotate(p.modenum, SEVENTHS);\n  return chords.map(function (chord, i) {\n    return fromDegree(i + 1, chord[0] !== \"m\");\n  });\n};\n/**\n * Get a list of the altered notes of a given Key. The notes will be in\n * the same order than in the key signature.\n *\n * @function\n * @param {string} key - the key name\n * @return {Array}\n *\n * @example\n * Key.alteredNotes(\"Eb major\") // => [ \"Bb\", \"Eb\", \"Ab\" ]\n */\n\nexport var alteredNotes = function (name) {\n  var alt = props(name).alt;\n\n  if (alt === null) {\n    return null;\n  }\n\n  return alt === 0 ? [] : alt > 0 ? range(1, alt).map(trFifths(\"B\")) : range(-1, alt).map(trFifths(\"F\"));\n};\n/**\n * Get a lead-sheet symbols for a given key name\n *\n * This function is currified (so can be partially applied)\n *\n * From http://openmusictheory.com/triads.html\n *\n * A lead-sheet symbol begins with a capital letter (and, if necessary,\n * an accidental) denoting the root of the chord.\n * That letter is followed by information about a chord’s quality:\n *\n * - major triad: no quality symbol is added\n * - minor triad: lower-case “m”\n * - diminished triad: lower-case “dim” or a degree sign “°”\n * - augmented triad: lower-case “aug” or a plus sign “+”\n *\n * @param {Array<string>} symbols - an array of symbols in major scale order\n * @param {string} keyName - the name of the key you want the symbols for\n * @param {Array<string>} [degrees] - the list of degrees. By default from 1 to 7 in ascending order\n * @return {function}\n * @see Key.chords\n * @see Key.triads\n *\n * @example\n * const chords = Key.leadsheetSymbols([\"M\", \"m\", \"m\", \"M\", \"7\", \"m\", \"dim\"])\n * chords(\"D dorian\") //=> [\"Dm\", \"Em\", \"FM\", \"G7\", \"Am\", \"Bdim\", \"CM\"]\n * chords(\"D dorian\", ['ii', 'V']) //=> [Em\", \"G7\"]\n */\n\nexport function leadsheetSymbols(symbols, keyName, degrees) {\n  if (arguments.length === 1) {\n    return function (n, d) {\n      return leadsheetSymbols(symbols, n, d);\n    };\n  }\n\n  var p = props(keyName);\n\n  if (!p.name) {\n    return [];\n  }\n\n  var names = rotate(p.modenum, symbols);\n  var chords = p.scale.map(function (tonic, i) {\n    return tonic + names[i];\n  });\n\n  if (!degrees) {\n    return chords;\n  }\n\n  return degrees.map(decimal).map(function (n) {\n    return chords[n - 1];\n  });\n}\n/**\n * Get key seventh chords\n *\n * @function\n * @param {string} name - the key name\n * @param {Array<number|string>} [degrees] - can be numbers or roman numerals\n * @return {Array<string>} seventh chord names\n *\n * @example\n * Key.chords(\"A major\") // => [\"AMaj7\", \"Bm7\", \"C#m7\", \"DMaj7\", ..,]\n * Key.chords(\"A major\", ['I', 'IV', 'V']) // => [\"AMaj7\", \"DMaj7\", \"E7\"]\n * Key.chords(\"A major\", [5, 4, 1]) // => [\"E7\", \"DMaj7\", AMaj7\"]\n */\n\nexport var chords = leadsheetSymbols(SEVENTHS);\n/**\n * Get key triads\n *\n * @function\n * @param {string} name - the key name\n * @param {Array<string|number>} [degrees]\n * @return {Array<string>} triad names\n *\n * @example\n * Key.triads(\"A major\") // => [\"AM\", \"Bm\", \"C#m\", \"DM\", \"E7\", \"F#m\", \"G#mb5\"]\n * Key.triads(\"A major\", ['I', 'IV', 'V']) // => [\"AMaj7\", \"DMaj7\", \"E7\"]\n * Key.triads(\"A major\", [1, 4, 5]) // => [\"AMaj7\", \"DMaj7\", \"E7\"]\n */\n\nexport var triads = leadsheetSymbols(TRIADS);\n/**\n * Get secondary dominant key chords\n *\n * @function\n * @param {string} name - the key name\n * @return {Array}\n *\n * @example\n * Key.secDomChords(\"A major\") // => [\"E7\", \"F#7\", ...]\n */\n\nexport var secDomChords = function (name) {\n  var p = props(name);\n\n  if (!p.name) {\n    return [];\n  }\n\n  return p.scale.map(function (t) {\n    return transpose(t, \"P5\") + \"7\";\n  });\n};\n/**\n * Get relative of a key. Two keys are relative when the have the same\n * key signature (for example C major and A minor)\n *\n * It can be partially applied.\n *\n * @function\n * @param {string} mode - the relative destination\n * @param {string} key - the key source\n *\n * @example\n * Key.relative(\"dorian\", \"B major\") // => \"C# dorian\"\n * // partial application\n * var minor = Key.relative(\"minor\")\n * minor(\"C major\") // => \"A minor\"\n * minor(\"E major\") // => \"C# minor\"\n */\n\nexport var relative = function (mode, key) {\n  if (arguments$1.length === 1) {\n    return function (key) {\n      return relative(mode, key);\n    };\n  }\n\n  var num = modenum(mode.toLowerCase());\n\n  if (num === undefined) {\n    return null;\n  }\n\n  var k = props(key);\n\n  if (k.name === null) {\n    return null;\n  }\n\n  return trFifths(k.tonic, FIFTHS[num] - FIFTHS[k.modenum]) + \" \" + mode;\n};\n/**\n * Split the key name into its components (pitch class tonic and mode name)\n *\n * @function\n * @param {string} name\n * @return {Array} an array in the form [tonic, key]\n *\n * @example\n * Key.tokenize(\"C major\") // => [\"C\", \"major\"]\n */\n\nexport var tokenize = function (name) {\n  var p = split(name);\n  p[3] = p[3].toLowerCase();\n\n  if (p[0] === \"\" || MODES.indexOf(p[3]) === -1) {\n    return [null, null];\n  }\n\n  return [p[0] + p[1], p[3]];\n};","map":null,"metadata":{},"sourceType":"module"}